# Контрольные вопросы


## 1. Сравнение clock_nanosleep и nanosleep
- `nanosleep` использует относительное время, т.е. «спи 2 мс от текущего момента».
- `clock_nanosleep` с `TIMER_ABSTIME` использует абсолютное время, т.е. «проснуться в момент X».

Почему для периодических задач в СРВ предпочтительнее clock_nanosleep с абсолютным временем:

- При использовании относительного сна ошибки накопливаются из-за вариаций времени пробуждения.

- Пример с nanosleep(2ms):
```
t0: start
t0+2ms: фактическое пробуждение 2.05ms → +0.05ms дрейф
t0+4ms: фактическое пробуждение 4.10ms → +0.10ms дрейф
t0+6ms: фактическое пробуждение 6.18ms → +0.18ms дрейф
...
```
- С `clock_nanosleep(TIMER_ABSTIME)` 
```
t0: start
t0+2ms: wake up
t0+4ms: wake up
t0+6ms: wake up
...
```
- дрейф не накапливается, период стабильный.


## 2. `timerfd` vs сигналы (POSIX timers)

- **POSIX таймеры через сигналы**
    * Прерывают поток в непредсказуемом месте.
    * Обработка требует осторожности в многопоточных приложениях.
- **`timerfd`**
    * Таймер представлен как файловый дескриптор.
    * Можно безопасно использовать с `poll/epoll`.
    * Более предсказуемая доставка событий, без неожиданных прерываний.

Вывод: для циклов обработки событий `timerfd` безопаснее и надежнее.

## 3. Инверсия приоритетов
-  Сценарий:
```
High-prio thread -> ждет mutex
Low-prio thread  -> держит mutex, но вытесняется планировщиком
Medium-prio thread -> выполняется
Результат: High-prio блокирован, Low-prio не может завершить -> инверсия приоритетов
```

- Решение: атрибут мьютекса `PTHREAD_PRIO_INHERIT` через `pthread_mutexattr_setprotocol`.
- Низкоприоритетный поток временно получает приоритет высокого потока.
- Это позволяет завершить критическую секцию и разблокировать High-prio.

## 4. Предсказуемость vs Производительность
- Техники из задания 4 (SCHED_FIFO, привязка к ядру, mlockall) повышают предсказуемость выполнения периодических задач, но могут снизить общую производительность системы.

- **Почему повышается предсказуемость:**
    * SCHED_FIFO обеспечивает реальное время: поток не вытесняется обычными задачами (SCHED_OTHER), что снижает джиттер.
    * Привязка к ядру (CPU affinity) исключает миграцию между ядрами, предотвращая кэш-промахи.
    * mlockall блокирует страницы памяти в RAM, предотвращая внезапные задержки из-за page faults.

- **Почему падает производительность:**
    * Поток с высоким приоритетом может вытеснять системные и пользовательские задачи, увеличивая задержку их выполнения.
    * CPU, закрепленное за RT-потоком, может простаивать для других процессов.
    * Вмешательство в планировщик снижает гибкость распределения ресурсов между задачами.

**Вывод:** жертвуя частично общей производительностью, мы получаем детерминированное и стабильное время отклика для критических задач.


## 5. Жесткое реальное время и PREEMPT_RT
- **Достаточно ли этих техник для жесткого реального времени?**

Нет. Даже с SCHED_FIFO, mlockall и привязкой к ядру Linux без патчей PREEMPT_RT не гарантирует строгое жесткое время отклика, потому что стандартное ядро не полностью детерминировано:
1. Есть критические секции в ядре, которые не прерываются (non-preemptible), что может вызвать непредсказуемые задержки.
2. Системные прерывания, драйверы и другие процессы могут внезапно блокировать RT-поток.

- **Что такое PREEMPT_RT:**

Патч или конфигурация ядра Linux для максимальной превентивности (preemption).
- Основные изменения:
1. Превращает большинство критических секций ядра в прерываемые mutex.
2. Превращает обработчики прерываний в реальные потоки, которые планируются по RT-политике.
3. Уменьшает или убирает непрерываемые участки кода, которые могут вызвать джиттер.

**Вывод:** PREEMPT_RT делает Linux ближе к жесткому реальному времени, обеспечивая детерминированные задержки, чего нельзя гарантировать только с SCHED_FIFO и привязкой к ядру на стандартном ядре.
