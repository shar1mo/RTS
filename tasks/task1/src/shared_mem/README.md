# Доступ к разделяемому ресурсу

- Проблема гонки: одновременная запись/чтение без синхронизации приводит к неконсистентным данным.
- Мьютексы: защищают критические секции, правило — как можно короче держите блокировку.
- Семафоры: счетные (N ресурсов) и двоичные (0/1); `sem_wait` — уменьшить, `sem_post` — увеличить.
- Условные переменные: синхронизация по событиям; всегда использовать с мьютексом, цикл ожидания — `while`.
- Producer-Consumer: два состояния (пусто/полно) или буфер; правильная сигнализация предотвращает спуриации и дедлоки.

## Память и порядок

- Использование мьютекса обеспечивает не только взаимное исключение, но и упорядочивание операций (happens-before) между потоками.
- Не полагайтесь на `volatile` для синхронизации: он не гарантирует атомарности и порядка, используйте мьютексы/атомики.

## Дедлоки, livelock, starvation

- Дедлок: взаимная блокировка — избегайте циклов захвата, используйте единый порядок блокировок (lock ordering).
- Livelock: потоки постоянно "уступают", но прогресса нет — ограничивайте ретраи, добавляйте экспоненциальную паузу.
- Starvation: поток не получает ресурса — учитывайте справедливость, по возможности применяйте честные очереди.

## Рекомендации

- Делайте критические секции короткими и предсказуемыми.
- Никогда не вызывайте блокирующий ввод/вывод (или долгое вычисление) под мьютексом.
- Ясно документируйте, какой мьютекс защищает какое состояние.

Практика:

- `nomutex.c` — демонстрация проблемы без синхронизации.
- `mutex.c` — выполнить студенту: защитить var1/var2 с мьютексом.
- `semex.c` — пример счетного семафора для пробуждения потребителей.
- `condvar.c` — двухсостоятая машина.
- `prodcons.c` — производитель/потребитель на condvar.
