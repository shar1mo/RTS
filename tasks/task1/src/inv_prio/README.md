# Инверсия приоритетов

- Ситуация: высокий приоритет (H) ждёт мьютекс у низкого (L), а средний (M) вытесняет L, увеличивая задержку H.
- Эффект — временная «инверсия» порядка выполнения.

## Диаграмма

- t=0: L захватывает мьютекс и входит в длинную критическую секцию.
- t=1: H пытается захватить мьютекс — блокируется.
- t=2: планировщик запускает M (не зависит от мьютекса), L вытесняется -> H ждёт, пока M занят.

## Протоколы

- Inheritance (PTHREAD_PRIO_INHERIT): при блокировке H на мьютексе L временно получает приоритет H, завершая критическую секцию быстрее.
- Ceiling (PTHREAD_PRIO_PROTECT): у мьютекса фиксированный "потолок" — поток при захвате получает этот приоритет, предотвращая вытеснение.

## Практика и ограничения

- На Linux требуется поддержка ядра/библиотеки для `PTHREAD_PRIO_INHERIT/PROTECT`. Не все конфигурации их включают.
- Настроить права/капабилити для использования `SCHED_FIFO/RR`.
- Критические секции должны быть короткими; избегайте I/O и сна под мьютексом.

Практика:

- `scenario_1.c` — демонстрация инверсии приоритетов на SCHED_FIFO без наследования.
- `scenario_2.c` — выполнить студенту: включить наследование/ceiling и сравнить задержку.
