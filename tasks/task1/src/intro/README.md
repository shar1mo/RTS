# intro

- Потоки POSIX (`pthread_create`, `pthread_join`) позволяют параллелизм на уровне процесса.
- Синхронизация: мьютексы (взаимное исключение), условные переменные (`pthread_cond_wait/signal`).
- Правило: всегда защищайте разделяемое состояние мьютексом; ожидание событий — только под мьютексом, цикл `while (!cond) wait(...)`.
- Безопасное завершение: используйте флаг завершения и будите ожидающие потоки.

## Атрибуты потоков и приоритеты

- `pthread_attr_t`: можно задавать политику планирования (`SCHED_OTHER`, `SCHED_FIFO`, `SCHED_RR`) и приоритет (`sched_param`). На Linux повышение приоритета реального времени требует прав (root/капабилити).
- Используйте явное наследование планирования: `pthread_attr_setinheritsched(attr, PTHREAD_EXPLICIT_SCHED)`.

## Условные переменные: шаблон использования

1. Захватить мьютекс.
2. Пока условие не выполнено — `pthread_cond_wait(&cond, &mutex)`.
3. После пробуждения — всегда перепроверять условие в `while` из‑за возможных ложных пробуждений.
4. Освободить мьютекс, при необходимости — `pthread_cond_signal/broadcast`.

Частые ошибки:

- Ожидание на `pthread_cond_wait` без захвата соответствующего мьютекса.
- Использование `if` вместо `while` вокруг `pthread_cond_wait`.
- Доступ к разделяемому состоянию без мьютекса.

Практика:

- `hello.c` — базовый ввод/вывод, аргументы командной строки.
- `intro.c` — 3 потока: считывание состояния, вывод изменений, UI.
